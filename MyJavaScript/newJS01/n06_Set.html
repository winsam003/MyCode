<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>** Collection Set **</title>
  <script>
    // ** Array
    // => 문자열의 중복을 허용하지 않는 배열 정의하기
    //   ( 조원들의 이름을 중복을 허용하지 않고 배열에 담기 )
    //    -> 1) 배열정의
    //    -> 2) 중복확인기능 (함수로 만들기)
    //    -> 3) 배열에 자료 담기
    // 1)
    let names = [];
    //let names = new Array();
    // 2) unique 확인 함수 만들기
    // =>  매개변수 text 로 전달된 값을 배열 names 의 요소들과 비교 해서
    //     동일값이 없으면 return true, 있으면 return false 
    const unique = (text) => {
        for ( let name of names ) {
          if ( text==name ) return false;
        } //for
        return true;
    }
    // 3) str 을 names 에 담기 (중복없이)
    let str = ['조현주', '조현주', '김이지', '김찬미', '김진휘', '김이지', '김찬미'];
    for ( let name of str ) {
      // 중복검사 후 담기
      if ( unique(name) ) names.push(name) ;
    }
    // 4) 출력 확인
    for ( let name of names ) {
      console.log(`** Name => ${name}`);
    }
    console.log(`** names.length => ${names.length}`);

    // ** Set 과 비교
    // => str -> mySet 에 담기
    // => Set 의 메서드: add, delete, has, size
    let mySet = new Set();
    for (let n of str) { mySet.add(n) }
    for(name of mySet) { console.log(`** Name = ${name}`); }

    mySet.delete('김진휘');
    mySet.delete('김진휘');  // 없는 값 delete 하는경우 (Error 없이 통과)
    console.log(`** mySet.has => 김진휘=${mySet.has('김진휘')}, 김찬미=${mySet.has('김찬미')}`);
    console.log(`** mySet.size => ${mySet.size}`);
    console.log(`** mySet 출력 => ${mySet}`);

    // => Set 생성과 동시에 초기화
    let mySet2 = new Set(str);

    // ** Set 메서드 체이닝
    // => 처리후 Set Type 을 return 하는 메서드는 계속 . 으로 연결해서 사용가능  
    //    단, delete, has 메서드는 boolean 을 return 하기 때문에 안됨.
    //    그러므로 마지막에 사용하면 가능함.
    mySet2.add('설수현').add('신혜진').add('연제승').add('설수현').delete('설수현');
    for(name of mySet2){ console.log(`** Name2 = ${name}`); }

    // ** forEach(CallBack함수) : 요소를 순회
    // => 이때 매개변수로 사용되는 CallBack함수 는 3개의 인수를 전달받음
    //    (현재 요소값, 현재 요소값, 현재 순회중인 set객체 자체)
    // => 배열의 forEach 메서드 Array.prototype.forEach 의 CallBack함수 인수 3개는
    //    (현재 요소값, 현재 인덱스, 현재 순회중인 배열객체 자체)
    // => Map의 forEach 메서드 Map.prototype.forEach 의 CallBack함수 인수 3개는
    //    (현재 value, 현재 key, 현재 순회중인 map객체 자체 )
    mySet2.forEach((v1, v2) => {
      console.log(`** forEach(함수) = ${v1}, ${v2}`);
    });

  </script>

</head>
<body>
  <pre>
    <h3>** 새로 추가된 컬렉션(collections) Set **</h3>
    => Set은 중복을 허용하지 않는 데이터(value) 들의 집합.
    => Set은 수정 가능하며, 프로그램이 실행되는 동안 값의 추가나 삭제 가능함.
      ( delete 성공시 true 를 반환하고 실패시 false 를 반환 )
    
    ** Set과 Array 의 차이점 **
    => 값이 중복되지 않습니다 ( 중복값은 저장하지 않음 )
      const mySet = new Set("abcd");
      mySet.size; // 4
      mySet.add("a");
      mySet.size; // 4
    
    => 데이터 확인이 편리하고 빠름.
      const mySet = new Set("abcd");
      const myArray = [..."abcd"];
        
      myArray.indexOf("a") !== -1 // true slow
      mySet.has("a")              // true fast	
      
    => Set은 인덱스 값으로 데이터 조회는 불가능
      myArray[0]; // "a"
      mySet[0];   // undefined
    </pre>
</body>
</html>